# MyTinyKVStore: 一个简单的持久化键值存储引擎

## ✨ 功能特性

* **持久化存储**: 所有数据都保存在一个数据文件中，关闭程序后不会丢失。
* **并发处理**: 采用生产者-消费者模型，支持多线程并发写入和删除，提升吞吐量。
* **崩溃安全**: 通过**预写日志 (Write-Ahead Log, WAL)** 机制，即使在操作过程中程序意外崩溃，也能在重启时恢复到一致的状态。
* **空间回收**: 采用**逻辑删除**配合**数据压缩 (Compaction)** 的机制，有效回收已删除数据占用的磁盘空间，防止文件无限膨胀。
* **LRU缓存**: 内置一个简单的最近最少使用（LRU）缓存，以加速热点数据的读取速度。

## 🏛️ 架构概览

1.  **异步任务队列**: 用户的 `Put` 和 `Delete` 请求不会立即执行，而是被封装成任务放入一个线程安全的队列中。后台的多个消费者线程负责从队列中取出任务并执行，实现了I/O操作的异步化。

2.  **预写日志 (WAL)**: 任何对数据的修改（写或删）都会**首先**以日志的形式追加到`.wal`文件中。只有当日志成功写入磁盘后，才会对内存和数据文件进行修改。这确保了即使在修改数据文件的过程中发生崩溃，我们也能通过重放日志来恢复数据。

3.  **逻辑删除**: 当用户删除一个键时，我们并不会立即去修改数据文件。我们只是在内存中记录一个“已删除”的标记，并向WAL写入一条删除日志。这样做的速度非常快，避免了昂贵的磁盘I/O。真正的物理删除被推迟到了数据压缩阶段。

4.  **数据压缩 (Compaction)**: 被触发时，会遍历当前所有有效的数据，将它们顺序写入一个新的数据文件中。所有被标记为“已删除”或已被更新的旧数据都会被自然地丢弃。写完后，用新文件原子地替换旧文件，从而完成空间回收。

## 🚀 开始使用

### 先决条件

在编译之前，请确保你的系统上已安装：
* **CMake** (版本 >= 3.10)
* 一个支持C++17的编译器 (例如 **GCC 7+** 或 **Clang 6+**)

### 编译步骤

你可以通过以下简单的步骤来编译工程：

```bash
# 1. 克隆或进入项目根目录
# git clone ...
cd /path/to/your/project

# 2. 创建一个构建目录
mkdir build
cd build

# 3. 运行CMake来配置项目
cmake ..

# 4. 使用Make来编译代码
make

# 5. 编译完成后，你会在build目录下看到一个名为 kv_test 的可执行文件
ls
# 输出应包含: kv_test
```

## ⚙️ 如何运行

我们提供了三种模式来测试和演示MiniKV的功能。

### 1. 基础功能测试 (默认)

这个测试会验证`Put`, `Get`, `Delete`的核心功能以及数据持久化是否正常。

**运行命令:**
```bash
./kv_test
```

### 2. 功能演示 (推荐)

这个测试更进一步，它会写入多种随机数据类型（字符串、整数、浮点数），删除其中一部分，然后重新加载数据库以验证持久性

**运行命令:**
```bash
./kv_test demo
```

### 3. 压力测试

这是一个长时间运行的并发测试，它会启动多个线程来疯狂地读、写、删数据，并定时触发数据压缩。这个测试是为检测并发bug和性能瓶颈而设计的。

**⚠️ 警告**: 此测试默认会运行12个小时。你可以通过修改`main.cpp`中的`stress_test`函数来调整运行时长。

**运行命令:**
```bash
./kv_test stress
```

## 💡 未来改进

* **支持字符串键**: 将`int`类型的键扩展为支持`std::string`。
* **范围查询**: 实现如`Scan(start_key, end_key)`之类的范围查询功能。
* **事务支持**: 为多个操作提供ACID事务保证。
* **自动压缩策略**: 根据文件大小、碎片率等指标自动触发压缩，而不是手动调用。
* **更完善的错误处理**: 引入自定义异常，而不是仅打印到`stderr`。

---
<small>本文框架由Gemini2.5pro生成</small>